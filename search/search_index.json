{
    "docs": [
        {
            "location": "/", 
            "text": "DBDocs\n\n\nThese are the documentation pages of Dave Bollinger, programmer and app developer.\n\n\n\n\nCorona SDK Plugins\n\n\nTVShader\n\n\n\n\nLinks\n\n\nWebsite/Blog\n\n\nTwitter\n\n\nGoogle Play Apps\n\n\nGitHub", 
            "title": "Home"
        }, 
        {
            "location": "/#dbdocs", 
            "text": "These are the documentation pages of Dave Bollinger, programmer and app developer.", 
            "title": "DBDocs"
        }, 
        {
            "location": "/#corona-sdk-plugins", 
            "text": "TVShader", 
            "title": "Corona SDK Plugins"
        }, 
        {
            "location": "/#links", 
            "text": "Website/Blog  Twitter  Google Play Apps  GitHub", 
            "title": "Links"
        }, 
        {
            "location": "/plugins/tvshader/", 
            "text": "TVShader\n\n\nIntroduction\n\n\n\"TVShader\" is a shader for Corona SDK that implements old-school style CRT effects.\n\n\nIt is intended for use when a full-screen \"retro\" effect is desired.\n\n\n\n\nThere are multiple aspects to the effect, including pincushion bulge, contrast and vignetting, color fringe separation (beam misalignment), scanlines, interference, tint, and flicker.\n\n\nIt is available from the \nCorona Marketplace\n\n\n\n\n\n\nQuick Start\n\n\nEnabling the Effect\n\n\nCopy the TVShader.lua module into your project folder.  (You may also copy it into any desired subdirectory of your project folder - you'd just need to account for that path in the sample code below.)\n\n\nRequire the TVShader module within your code where it will be used.\n\n\nlocal TVShader = require(\nTVShader\n)\n\n\n\n\nCreate two display groups - one to hold the original contents of your display, and one to hold the output from the effect.\n\n\nlocal contentGroup = display.newGroup()\nlocal effectGroup = display.newGroup()\n\n\n\n\nCreate an instance of the shader, passing it references to the two groups:\n\n\nlocal tvshader = TVShader({\n  contentGroup = contentGroup,\n  effectGroup = effectGroup\n})\n\n\n\n\nThat's basically it.\n\n\nThe effect will now be active, but only a bit of interference lines will be visible on the otherwise blank screen.\n\n\nGiving the Effect Something To Process\n\n\nIn order to actually \nnotice\n the effect it would help to have some actual content to receive the effect.\nAny display objects added to the contentGroup will be processed by the effect.\n\n\nFor these purposes, a simple square will do...\n\n\nlocal rect = display.newRect( contentGroup, 240, 160, 200, 200 )\nrect:setFillColor(0.8)\n\n\n\n\n\n\nDisabling the Effect\n\n\nTurning the effect off is accomplished by destroying the instance.\n\n\ntvshader:destroy()\n\n\n\n\n\n\n\n\nAPI Reference\n\n\nTVShader(params)\n\n\nCreates an instance of the TVShader.  Once created, an instance of the shader is immediately active.\n\n\nThis function takes a single argument, \nparams\n, a table that accepts the following parameters:\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nReq/Opt\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncontentGroup\n\n\nDisplay Group\n\n\nRequired\n\n\nA reference to a display group that contains the source content to be processed by the effect.\n\n\n\n\n\n\neffectGroup\n\n\nDisplay Group\n\n\nRequired\n\n\nA reference to a display group that will contain the output of the effect.  The effectGroup should be empty.\n\n\n\n\n\n\nstaticContent\n\n\nBoolean\n\n\nOptional\n\n\nA boolean indicating if the contents of the contentGroup are static (true) or animated (false, default).  If the contents are static, then setting this value to true may improve overall performance.\n\n\n\n\n\n\n\n\nExample:\n (dynamic/animated content)\n\n\nlocal tvshader = TVShader({\n  contentGroup = myContentGroup,\n  effectGroup = myEffectGroup,\n})\n\n\n\n\nExample:\n (static content)\n\n\nlocal tvshader = TVShader({\n  contentGroup = myContentGroup,\n  effectGroup = myEffectGroup,\n  staticContent = true\n})\n\n\n\n\nNotes:\n\n\nThe contentGroup should be properly \"layered\" (ie, inserted into an appropriate parent group) in the display heirarchy prior to being assigned to the effect.\n\n\nThe contentGroup will be removed from its current parent group to prevent rendering of the un-effect-ed content.\n\n\nThe contents of the contentGroup may be altered after having been assigned to the shader.  You may insert new display objects into the contentGroup, or remove existing objects.  Any objects in the contentGroup will receive the effect.\n\n\nHowever, if you create an instance with staticContent=true, then \nlater\n add elements to the contentGroup (thus it is \nnon\n-static), you must manually invalidate (see below) the effect in order to see those changes.\n\n\nNote that the contentGroup \nitself\n should not be altered after having been assigned to the shader.  For instance, you should not attempt to insert the contentGroup into some other parent group while it is in use by the shader.\n\n\n\n\ninstance\n:invalidate()\n\n\nManually refreshes the offscreen texture to reflect the current contents of the contentGroup.\n\n\nThis function takes no arguments.\n\n\nExample:\n\n\ntvshader:invalidate()\n\n\n\n\nTypically only needed if the instance was created with staticContent=true, yet some later change \ndoes\n occur to the contentGroup that you wish to be reflected in the effect.\n\n\nIf the instance was created with staticContent=false (the default) then any changes to the contents of the contentGroup will be automatically reflected in the effect, thus this method will not be needed.\n\n\n\n\ninstance\n:destroy()\n\n\nDestroys an instance of the TVShader.  Once destroyed, an instance of the shader is immediately deactivated.  The contentGroup is returned to it's original parent.\n\n\nThis function takes no arguments.\n\n\nExample:\n (typical)\n\n\ntvshader:destroy()\n\n\n\n\nThis function returns a single value - a reference to the original contentGroup.  This value is typically not needed as long as the original display heirarchy exists as it did at the time the shader was created.\n\n\nHowever, if the display heirarchy has changed such that the original parent of the contentGroup is no longer a suitable location to restore the contentGroup to, you may use the return value to insert the contentGroup into some \nother\n parent group.\n\n\nExample:\n (using the return value)\n\n\n  scene.view:insert( tvshader:destroy() )\n\n\n\n\n\n\n\n\nLimitations / Caveats\n\n\nPerformance Considerations\n\n\nThis effect is achieved by rendering the contentGroup to an offscreem texture, then applying that texture to a rectangle in the outputGroup.\n\n\nThis results in non-trivial performance implications.\n\n\nGPU texture memory will be allocated for the offscreen texture into which the contentGroup is rendered.\n\n\nGPU load will increase due to the effective double-rendering of the contentGroup.  This will be more pronounced when the contents of\nthe contentGroup are dynamic (ie, staticContent=false was passed, or defaulted, during instance creation).\n\n\nYou should performance test this effect on target devices.\n\n\n\n\nDisplay Quality Considerations\n\n\nAs a trade-off to the above performance considerations, texture memory is limited to content resolutions.\n\n\nThis may cause a degredation in display quality if you are running on a high-resolution / high-density device with significantly lower content dimensions.\n\n\nThis is partially mitigated by the fact that this effect is \nintended\n to simulate a poor-quality display device.  That is, you may actually\nfind this behavior \nbeneficial\n.\n\n\n\n\nUser Interface Elements\n\n\nThis is a visual-only effect -- user interface elements requiring touch events should not be part of the content group.  Touch events will\nnot propogate through the effect output to the individual children of the group, including user interface elements.\n\n\nThis is typically not a practical limitation, as you probably won't \nwant\n user interface elements effected (\nsic\n).   User interface elements would\nbehave unusually even if they \nwere\n able to receive touch events while subject to the effect, due to the pincushion displacement of the effect - the\nactual touch bounds of such user interface elements would not coincide with their pincushioned display.\n\n\nHowever, it is possible, with a bit of clever coding, to create \ntwo sets\n of user interface elements - one visible and effected, one invisible\nand not effected -- if you are determined to have effected user interface elements, and can tolerate the slight visual misrepresentation of their\npincushioned location.  It will be up to you to keep the visual element in sync with the invisible and touch-able element.\n\n\n\n\n\n\nDemos\n\n\nThe distribution file includes several demos, ranging from very-simple to more-complex usage.\n\n\nBeachBallDemo\n is illustrated above in the Introduction section.\n\n\nDemo0_FromDocs\n is illusated above in the Quick Start section.\n\n\nDemo1_Simplest\n presents simple static content usage.\n\n\nDemo2_SimplestToggled\n builds on Demo1_Simplest, and toggles the effect on/off via a timer.\n\n\nDemo3_Fishies\n borrows from Corona's \"Fishies\" sample to illustrate dynamic content, and how to go about \"patching\" an existing project to use the effect.\n(some extraneous details from the original Fishies sample are excluded, specifically orientation support)\n\n\nDemo4_Clock\n borrows from Corona's \"Clock\" sample to illustrate dynamic content AND non-effected UI elements.\n\n\nDemo5_Composer\n borrows from Corona's \"Composer\" sample to illustrate multiple instances of the effect, as well as proper timing for their creation/destruction\nwhen used with Composer.\n\n\nAll demos were last tested against Daily Build 3310.\n\n\n\n\n\n\n\n\nSource Code\n\n\nThe distribution file includes full source code.  It's only around 200 lines of commented code -- you should expect about a ten minute read (depending on your\nbackground) to obtain a reasonable understanding of its inner workings.\n\n\nSource code is provided mainly for those wishing to alter the shader kernel internals.  There are far too many potential variables to pass them as run-time\nparameters to the shader, for practical purposes anway, so the shader's kernel is \"hard-coded\".  For example, you may wish to disable the pincushion effect,\nor increase the intensity of the flicker effect, or alter the color tint, et cetera - all of which are clearly indicated by comments.\n\n\nIf you wish, you may even alter the kernel to such an extent as to create an entirely new class of shader.\n\n\nJust keep in mind the \nMarket's EULA\n regarding redistribution of any such modifications, other than as incorporated\ninto your own applications.\n\n\nSource code is also provided in lieu of warranty.  If you discover a bug or other flaw in the code, please feel free to advise me and I'll make best efforts\nto rectify it.  But in the mean time, you yourself have the ability to do so as well.  I myself hate waiting for resolutions of closed-source bugs, so I don't\nwish to perpetuate that problem.", 
            "title": "TVShader"
        }, 
        {
            "location": "/plugins/tvshader/#tvshader", 
            "text": "", 
            "title": "TVShader"
        }, 
        {
            "location": "/plugins/tvshader/#introduction", 
            "text": "\"TVShader\" is a shader for Corona SDK that implements old-school style CRT effects.  It is intended for use when a full-screen \"retro\" effect is desired.   There are multiple aspects to the effect, including pincushion bulge, contrast and vignetting, color fringe separation (beam misalignment), scanlines, interference, tint, and flicker.  It is available from the  Corona Marketplace", 
            "title": "Introduction"
        }, 
        {
            "location": "/plugins/tvshader/#quick-start", 
            "text": "", 
            "title": "Quick Start"
        }, 
        {
            "location": "/plugins/tvshader/#enabling-the-effect", 
            "text": "Copy the TVShader.lua module into your project folder.  (You may also copy it into any desired subdirectory of your project folder - you'd just need to account for that path in the sample code below.)  Require the TVShader module within your code where it will be used.  local TVShader = require( TVShader )  Create two display groups - one to hold the original contents of your display, and one to hold the output from the effect.  local contentGroup = display.newGroup()\nlocal effectGroup = display.newGroup()  Create an instance of the shader, passing it references to the two groups:  local tvshader = TVShader({\n  contentGroup = contentGroup,\n  effectGroup = effectGroup\n})  That's basically it.  The effect will now be active, but only a bit of interference lines will be visible on the otherwise blank screen.", 
            "title": "Enabling the Effect"
        }, 
        {
            "location": "/plugins/tvshader/#giving-the-effect-something-to-process", 
            "text": "In order to actually  notice  the effect it would help to have some actual content to receive the effect.\nAny display objects added to the contentGroup will be processed by the effect.  For these purposes, a simple square will do...  local rect = display.newRect( contentGroup, 240, 160, 200, 200 )\nrect:setFillColor(0.8)", 
            "title": "Giving the Effect Something To Process"
        }, 
        {
            "location": "/plugins/tvshader/#disabling-the-effect", 
            "text": "Turning the effect off is accomplished by destroying the instance.  tvshader:destroy()", 
            "title": "Disabling the Effect"
        }, 
        {
            "location": "/plugins/tvshader/#api-reference", 
            "text": "", 
            "title": "API Reference"
        }, 
        {
            "location": "/plugins/tvshader/#tvshaderparams", 
            "text": "Creates an instance of the TVShader.  Once created, an instance of the shader is immediately active.  This function takes a single argument,  params , a table that accepts the following parameters:     Name  Type  Req/Opt  Description      contentGroup  Display Group  Required  A reference to a display group that contains the source content to be processed by the effect.    effectGroup  Display Group  Required  A reference to a display group that will contain the output of the effect.  The effectGroup should be empty.    staticContent  Boolean  Optional  A boolean indicating if the contents of the contentGroup are static (true) or animated (false, default).  If the contents are static, then setting this value to true may improve overall performance.     Example:  (dynamic/animated content)  local tvshader = TVShader({\n  contentGroup = myContentGroup,\n  effectGroup = myEffectGroup,\n})  Example:  (static content)  local tvshader = TVShader({\n  contentGroup = myContentGroup,\n  effectGroup = myEffectGroup,\n  staticContent = true\n})  Notes:  The contentGroup should be properly \"layered\" (ie, inserted into an appropriate parent group) in the display heirarchy prior to being assigned to the effect.  The contentGroup will be removed from its current parent group to prevent rendering of the un-effect-ed content.  The contents of the contentGroup may be altered after having been assigned to the shader.  You may insert new display objects into the contentGroup, or remove existing objects.  Any objects in the contentGroup will receive the effect.  However, if you create an instance with staticContent=true, then  later  add elements to the contentGroup (thus it is  non -static), you must manually invalidate (see below) the effect in order to see those changes.  Note that the contentGroup  itself  should not be altered after having been assigned to the shader.  For instance, you should not attempt to insert the contentGroup into some other parent group while it is in use by the shader.", 
            "title": "TVShader(params)"
        }, 
        {
            "location": "/plugins/tvshader/#instanceinvalidate", 
            "text": "Manually refreshes the offscreen texture to reflect the current contents of the contentGroup.  This function takes no arguments.  Example:  tvshader:invalidate()  Typically only needed if the instance was created with staticContent=true, yet some later change  does  occur to the contentGroup that you wish to be reflected in the effect.  If the instance was created with staticContent=false (the default) then any changes to the contents of the contentGroup will be automatically reflected in the effect, thus this method will not be needed.", 
            "title": "instance:invalidate()"
        }, 
        {
            "location": "/plugins/tvshader/#instancedestroy", 
            "text": "Destroys an instance of the TVShader.  Once destroyed, an instance of the shader is immediately deactivated.  The contentGroup is returned to it's original parent.  This function takes no arguments.  Example:  (typical)  tvshader:destroy()  This function returns a single value - a reference to the original contentGroup.  This value is typically not needed as long as the original display heirarchy exists as it did at the time the shader was created.  However, if the display heirarchy has changed such that the original parent of the contentGroup is no longer a suitable location to restore the contentGroup to, you may use the return value to insert the contentGroup into some  other  parent group.  Example:  (using the return value)    scene.view:insert( tvshader:destroy() )", 
            "title": "instance:destroy()"
        }, 
        {
            "location": "/plugins/tvshader/#limitations-caveats", 
            "text": "", 
            "title": "Limitations / Caveats"
        }, 
        {
            "location": "/plugins/tvshader/#performance-considerations", 
            "text": "This effect is achieved by rendering the contentGroup to an offscreem texture, then applying that texture to a rectangle in the outputGroup.  This results in non-trivial performance implications.  GPU texture memory will be allocated for the offscreen texture into which the contentGroup is rendered.  GPU load will increase due to the effective double-rendering of the contentGroup.  This will be more pronounced when the contents of\nthe contentGroup are dynamic (ie, staticContent=false was passed, or defaulted, during instance creation).  You should performance test this effect on target devices.", 
            "title": "Performance Considerations"
        }, 
        {
            "location": "/plugins/tvshader/#display-quality-considerations", 
            "text": "As a trade-off to the above performance considerations, texture memory is limited to content resolutions.  This may cause a degredation in display quality if you are running on a high-resolution / high-density device with significantly lower content dimensions.  This is partially mitigated by the fact that this effect is  intended  to simulate a poor-quality display device.  That is, you may actually\nfind this behavior  beneficial .", 
            "title": "Display Quality Considerations"
        }, 
        {
            "location": "/plugins/tvshader/#user-interface-elements", 
            "text": "This is a visual-only effect -- user interface elements requiring touch events should not be part of the content group.  Touch events will\nnot propogate through the effect output to the individual children of the group, including user interface elements.  This is typically not a practical limitation, as you probably won't  want  user interface elements effected ( sic ).   User interface elements would\nbehave unusually even if they  were  able to receive touch events while subject to the effect, due to the pincushion displacement of the effect - the\nactual touch bounds of such user interface elements would not coincide with their pincushioned display.  However, it is possible, with a bit of clever coding, to create  two sets  of user interface elements - one visible and effected, one invisible\nand not effected -- if you are determined to have effected user interface elements, and can tolerate the slight visual misrepresentation of their\npincushioned location.  It will be up to you to keep the visual element in sync with the invisible and touch-able element.", 
            "title": "User Interface Elements"
        }, 
        {
            "location": "/plugins/tvshader/#demos", 
            "text": "The distribution file includes several demos, ranging from very-simple to more-complex usage.  BeachBallDemo  is illustrated above in the Introduction section.  Demo0_FromDocs  is illusated above in the Quick Start section.  Demo1_Simplest  presents simple static content usage.  Demo2_SimplestToggled  builds on Demo1_Simplest, and toggles the effect on/off via a timer.  Demo3_Fishies  borrows from Corona's \"Fishies\" sample to illustrate dynamic content, and how to go about \"patching\" an existing project to use the effect.\n(some extraneous details from the original Fishies sample are excluded, specifically orientation support)  Demo4_Clock  borrows from Corona's \"Clock\" sample to illustrate dynamic content AND non-effected UI elements.  Demo5_Composer  borrows from Corona's \"Composer\" sample to illustrate multiple instances of the effect, as well as proper timing for their creation/destruction\nwhen used with Composer.  All demos were last tested against Daily Build 3310.", 
            "title": "Demos"
        }, 
        {
            "location": "/plugins/tvshader/#source-code", 
            "text": "The distribution file includes full source code.  It's only around 200 lines of commented code -- you should expect about a ten minute read (depending on your\nbackground) to obtain a reasonable understanding of its inner workings.  Source code is provided mainly for those wishing to alter the shader kernel internals.  There are far too many potential variables to pass them as run-time\nparameters to the shader, for practical purposes anway, so the shader's kernel is \"hard-coded\".  For example, you may wish to disable the pincushion effect,\nor increase the intensity of the flicker effect, or alter the color tint, et cetera - all of which are clearly indicated by comments.  If you wish, you may even alter the kernel to such an extent as to create an entirely new class of shader.  Just keep in mind the  Market's EULA  regarding redistribution of any such modifications, other than as incorporated\ninto your own applications.  Source code is also provided in lieu of warranty.  If you discover a bug or other flaw in the code, please feel free to advise me and I'll make best efforts\nto rectify it.  But in the mean time, you yourself have the ability to do so as well.  I myself hate waiting for resolutions of closed-source bugs, so I don't\nwish to perpetuate that problem.", 
            "title": "Source Code"
        }
    ]
}